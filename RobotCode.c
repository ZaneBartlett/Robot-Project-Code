#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    IRsensor1,      sensorReflection)
#pragma config(Sensor, dgtl2,  button1,        sensorTouch)
#pragma config(Sensor, dgtl8,  RangeFinder,    sensorSONAR_cm)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           m1,            tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,           m3,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           m4,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          m2,            tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

bool button1_pushed;

// changes the threshold value as the robot gets closer to the beacon to ensure the correct alignment with the beacon
int get_light_threshold(){

	int light_threshold;
	//if the robot is more than 75 cm from the beacon threshold is 150 to ensure it is found
	if((SensorValue(RangeFinder) >= 75) || SensorValue(RangeFinder) < 0){

		light_threshold = 100;

		//if the robot is closer than 50 cm from the beacon threshold is 250 to find centre of beacon
	}else if((SensorValue(RangeFinder) < 75) && (SensorValue(RangeFinder) >= 50)){

		light_threshold = 250;
		//if robot is closer than 50 cm, farther than 25, threshold is 750
	}else if((SensorValue(RangeFinder) < 50) && (SensorValue(RangeFinder) >= 25)){

		light_threshold = 750;
		//if closer than 25 cm threshold is 950
	}else if(SensorValue(RangeFinder) < 25){

		light_threshold = 950;
	}
	// returns what the light threshold is based on distance to beacon
	return light_threshold;
}

typedef enum T_Robot_State{
	Idle_State = 0,
	Scan_State,
	Forward_State,
	Reverse_State,
	Connect_State
} T_Robot_State;	//FSM to control what the robot is doing



// Perform processing of measurements.
// Should be called with rate of at least 20 Hertz for proper detection of puck.
bool monitorLight(){

	int light_threshold = get_light_threshold();

	static int minLevelIR1 = 4096;	// Minimum light level seen by IR sensor 1
	static int maxLevelIR1 = 0;			// Maximum light level seen by IR sensor 1
	static int diffLevelIR1 = 0;		// Delta between maximum and minimum seen in last 0.1 seconds

	int lightLevel1 = SensorValue[IRsensor1];
	bool returnValue;

	// Check if 100 msecs have elapsed.
	if ( time1[T1] > 100 )  {

		// 100 msecs have elapsed.  Compute delta of light level.
		diffLevelIR1 = maxLevelIR1 - minLevelIR1;

		// Reset calculation for next 100 msecs.
		maxLevelIR1 = 0;
		minLevelIR1 = 4096;
		clearTimer(T1);

		} else {

		// Check for new minimum/maximum light levels.
		if ( lightLevel1 < minLevelIR1 ) {

			minLevelIR1 = lightLevel1;

			} else if ( lightLevel1 > maxLevelIR1 ) {

			maxLevelIR1 = lightLevel1;

		}
	}

	// Check if light level difference over threshold.
	if ( diffLevelIR1 > light_threshold ) {

		returnValue = true;
		} else {
		returnValue = false;
	}

	return(returnValue);

}	// end monitorLight



//this function reads input for the push button and stores the value in a bool. Called frequently
void monitorInput(){

	if(SensorValue(button1) && !button1_pushed){
		button1_pushed = true;
	}								//end if

}	//end monitorInput





task main(){

	T_Robot_State RobotState = Idle_State; // starts the robot with all motors off

	bool beaconVisible; //bool to determine if robot is detecting a swing equal to or larger than the threshold value

	//ensures the swing arm is closed
	motor(m4) = -30;

	while(true){

		//updates push buttons
		monitorInput();

		if(button1_pushed){
			//updates beacon visible frequently to ensure robot is still driving towards beacon
			beaconVisible = monitorLight();
			//updates push button flags
			monitorInput();


			//if the robot is not aimed at the beacon, scan for it
			if(beaconVisible == false){

				RobotState = Scan_State;
			}

			//if the robot is aimed at the beacon and not at the correct distance to connect
			//robot will drive forward
			if( ((beaconVisible == true) && (SensorValue(RangeFinder) >= 10)) || ((beaconVisible == true) && (SensorValue(RangeFinder) > 0)) ){

				RobotState = Forward_State;
			}

			//if robot is close enough to connect and is aimed at the beacon
			//robot will connect the cable then the loop will break
			// ending the robot's operation
			if( ((SensorValue(RangeFinder) <= 10)&& (SensorValue(RangeFinder) > 0)) && (beaconVisible == true) ){

			//robot waits to ensure it has come to a complete stop
				wait1Msec(1000);

				//turns slightly to centre the beacon and robot
				motor(m1) = 25;
				motor(m2) = -25;
				wait1Msec(200);
				motor(m1) = 0;
				motor(m2) = 0;

				RobotState = Connect_State;

			}

			//if the robot is not aimed at the beacon, but is too close to the wall, it will back up then scan fro the beacon
			if( (beaconVisible == false) && ((SensorValue(RangeFinder) < 20)&& (SensorValue(RangeFinder) > 0))  ){

				RobotState = Reverse_State;

			}


			switch(RobotState){
			case Idle_State:
			// turns all motors off
				motor(m1) = 0;
				motor(m2) = 0;
				motor(m3) = 0;
				motor(m4) = 0;
				break;
			case Scan_State:
				// while the beacon is not visible and the robot is an appropriate distance
				// from the wall it will scan for the beacon
				while( (beaconVisible == false) && (SensorValue(RangeFinder) >= 20) ){
					motor(m1) = 35;
					motor(m2) = -35;
					beaconVisible = monitorLight();
				}

				//temporarily stops robot operation
				motor(m1) = 0;
				motor(m2) = 0;
				break;
			case Forward_State:
			//while the beacon is visible and the robot is not at the
			// appropriate distance from the beacon for connection
			//robot drives towards the beacon
				while( (SensorValue(RangeFinder) >= 10) && (beaconVisible == true) ){
					motor(m1) = 40;
					motor(m2) = 40;
					beaconVisible = monitorLight();
				}

				//motors shuts off
				motor(m1) = 0;
				motor(m2) = 0;
				break;
			case Reverse_State:
				// while the beacon is not see and the robot is too close to the
				// wall robot backs up
				while( (SensorValue(RangeFinder) <= 30) && (beaconVisible == false) ){
					motor(m1) = -30;
					motor(m2) = -30;
					beaconVisible = monitorLight();
				}
				// motors shut off
				motor(m1) = 0;
				motor(m2) = 0;

				RobotState = Scan_State;

				break;
			case Connect_State:

				// gear turns to feed out connection piece
				motor(m3) = -25;
				wait1Msec(1000);
				motor(m3) = 0;

				// arm opens up to ensure no string caught in the gears
				motor(m4) = -25;
				wait1Msec(500);
				motor(m4) = 0;

				// robot quickly backs up then the motors stop
				motor(m1) = -35;
				motor(m2) = -35;
				wait1Msec(2000);
				motor(m1) = 0;
				motor(m2) = 0;

				//will cause loop to break
				button1_pushed = false;
				break;
			}

	}

	}





}
